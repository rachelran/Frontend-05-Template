# 学习笔记

## 字典树
大量高重复字符串的存储与分析

## KMP
在长字符串里找模式  
具体方法： 
- 求跳转表格
- 进行匹配    

求跳转表格最重要的一步，是寻找最长前缀后缀，举个例子：   
如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：  

| 模式串的各个子串  | 前缀 |  后缀 | 最大公共元素长度 |
| :---: | :---: | :---: | :---: |
| A  | 空  | 空  | 0  |
| AB  | A  | B  | 0  |
| ABC  | A,BC  | C,BC  | 0  |
| ABCD  | A,AB,ABC  | D,CD,BCD  | 0  |
| ABCDA  | A,AB,ABC,ABCD  | A,DA,CDA,BCDA  | 1 |
| ABCDAB  |A,AB,ABC,ABCD,ABCDA  | B,AB,DAB,CDAB,BCDAB  | 2  |
| ABCDABD  | A,AB,ABC,ABCD,ABCDA,ABCDAB  | D,BD,ABD,DABD,CDABD,BCDABD  | 0  |   

则原模式串字串匹配的最大长度表格所得到的跳转表格为：   

| 字符  | A |  B | C | D |  A | B | D |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 匹配 | 0 | 0 | 0 | 0 | 1 | 2 | 0 |

在匹配过程中，模式字符串和原串逐个字符匹配，如果出现不匹配的情况，根据跳转表格而不需要跳回最初位置，根据跳转表格所指定的位置，继续匹配，这也是优于暴力匹配的优势所在

## wildcard
带通配符的字符串模式（？匹配任意字符，*匹配任意数量的任意字符）  
具体方法：
- 最后一个星号匹配尽可能多的，最后一个前面的星号匹配少的  
- 逐段的转换成exec，处理正则

## 正则
字符串通用模式匹配

## 状态机
通用的字符串分析

## LL LR
字符串多层级结构分析

